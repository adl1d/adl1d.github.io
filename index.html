
(3.) Playfair Cipher:
<!--Playfair-->

      <!DOCTYPE html>
      <html lang="en">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Playfair Cipher</title>
      </head>
      <body>
      
      <div class="container">
        <div class="border p-3 rounded shadow mt-2" id="Playfair Cipher">
          <h2>(3.) Playfair Cipher</h2>
      </head>
      <body>
      <div class="border p-3 rounded shadow mt-2" id="pf_block">
        <form id="playfair_form" action="#pf_block">
          Plain Text: <input type="text" id="pf_text" class="form-control" placeholder="Enter a text to encrypt">
          Key: <input type="text" id="pf_key" class="form-control" placeholder="Enter a key">
          <button id="pf_enc_btn" class="btn btn-primary mt-2" type="button" onclick="runPlayfairEncrypt()">Encrypt</button>
          <button id="pf_denc_btn" class="btn btn-secondary mt-2" type="button" onclick="runPlayfairDecrypt()">Decrypt</button>
        </form>
        <div class="mt-4 border p-3 rounded">
          <b>Encrypted/Decrypted Text:</b>
          <div id="pf_result" class="border rounded p-2" style="background-color: #e4e4e4; color: rgb(255, 0, 0);"></div>
        </div>
      </div>
    </div>
  </div>
</div>
      <script type="text/javascript">
        const alphabet = 'ABCDEFGHIKLMNOPQRSTUVWXYZ';
      
        function runPlayfairEncrypt() {
          const plaintext = document.getElementById("pf_text").value.toUpperCase().replace(/J/g, 'I');
          const key = document.getElementById("pf_key").value.toUpperCase().replace(/J/g, 'I');
      
          if (plaintext.length === 0 || key.length === 0) {
            alert("Text and key fields cannot be empty!");
            return;
          }
      
          const matrix = generatePlayfairMatrix(key);
          const encryptedText = playfairEncrypt(plaintext, matrix);
      
          document.getElementById("pf_result").textContent ="Encrypted Text: " + encryptedText;
        }
      
        function runPlayfairDecrypt() {
          const encryptedText = document.getElementById("pf_text").value.toUpperCase().replace(/J/g, 'I');
          const key = document.getElementById("pf_key").value.toUpperCase().replace(/J/g, 'I');
      
          if (encryptedText.length === 0 || key.length === 0) {
            alert("Text and key fields cannot be empty!");
            return;
          }
      
          const matrix = generatePlayfairMatrix(key);
          const decryptedText = playfairDecrypt(encryptedText, matrix);
      
          document.getElementById("pf_result").textContent ="Decrypted Text: " + decryptedText;
        }
      
        function generatePlayfairMatrix(key) {
          key = key.replace(/J/g, 'I');
          key = key.toUpperCase();
          key = key.replace(/[^A-Z]/g, ''); // Remove non-alphabet characters
          key = [...new Set(key)]; // Remove duplicates
          const matrix = [];
      
          for (let i = 0; i < key.length; i++) {
            if (matrix.length === 0 || matrix[matrix.length - 1].length === 5) {
              matrix.push([]);
            }
            matrix[matrix.length - 1].push(key[i]);
          }
      
          for (let i = 0; i < alphabet.length; i++) {
            if (!key.includes(alphabet[i])) {
              if (matrix.length === 0 || matrix[matrix.length - 1].length === 5) {
                matrix.push([]);
              }
              matrix[matrix.length - 1].push(alphabet[i]);
            }
          }
      
          return matrix;
        }
      
        function playfairEncrypt(plaintext, matrix) {
          const pairs = getLetterPairs(plaintext);
          let encryptedText = '';
      
          pairs.forEach(pair => {
            const [row1, col1] = findPosition(matrix, pair.charAt(0));
            const [row2, col2] = findPosition(matrix, pair.charAt(1));
      
            if (row1 === row2) {
              encryptedText += matrix[row1][(col1 + 1) % 5] + matrix[row2][(col2 + 1) % 5];
            } else if (col1 === col2) {
              encryptedText += matrix[(row1 + 1) % 5][col1] + matrix[(row2 + 1) % 5][col2];
            } else {
              encryptedText += matrix[row1][col2] + matrix[row2][col1];
            }
          });
      
          return encryptedText;
        }
      
        function playfairDecrypt(encryptedText, matrix) {
          const pairs = getLetterPairs(encryptedText);
          let decryptedText = '';
      
          pairs.forEach(pair => {
            const [row1, col1] = findPosition(matrix, pair.charAt(0));
            const [row2, col2] = findPosition(matrix, pair.charAt(1));
      
            if (row1 === row2) {
              decryptedText += matrix[row1][(col1 - 1 + 5) % 5] + matrix[row2][(col2 - 1 + 5) % 5];
            } else if (col1 === col2) {
              decryptedText += matrix[(row1 - 1 + 5) % 5][col1] + matrix[(row2 - 1 + 5) % 5][col2];
            } else {
              decryptedText += matrix[row1][col2] + matrix[row2][col1];
            }
          });
      
          return decryptedText;
        }
      
        // Utility functions
        function getLetterPairs(text) {
          text = text.toUpperCase().replace(/J/g, 'I');
          const pairs = [];
      
          for (let i = 0; i < text.length; i += 2) {
            if (i + 1 < text.length) {
              pairs.push(text.substr(i, 2));
            } else {
              pairs.push(text.charAt(i) + 'X');
            }
          }
          return pairs;
        }
        function findPosition(matrix, letter) {
          for (let row = 0; row < matrix.length; row++) {
            for (let col = 0; col < matrix[row].length; col++) {
              if (matrix[row][col] === letter) {
                return [row, col];
              }
            }
          }
          return [-1, -1]; // Not found
        }
      </script>
      </body>
      </html>
